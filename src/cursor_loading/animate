#!/usr/bin/python3

# This cursor is just a hard copy of loading_circle with cursor_ul linked.
# I really don't wanna link loading_circle, as writing the code for animating
# would take longer than just copy-pasting the new circle when it updates.
# This is because there's two options for animating the linked image:
# 1) Write a massive amount of code to interpret the fucky transformation system.
#    In inkscape the rotation starts from the corner of the image,
#    and the image of course expands bounds to fit.
#    This means when you rotate an image, you have to move the corner of that image
#    a very weird amount to compensate for the rotation.
#    To top it off, saving the transformation uses negative scaling for 180* rotation
#    and the file just axes the transform modifier all-together at 0*, requiring the
#    code to be able to detect and possibly write both of those.
#    Maybe in the future I'll need to do this anyway and will write a small library.
# 2) Instead of updating the image in cursor_loading.svg, you could update the link
#    to point to a temporary version of loading_cursor.svg. However,
#    to parallelize this would mean saving 32 separate temp images somewhere.
#    Not *bad* but not elegant. If copy-pasting becomes a problem I'll probably
#    use this solution and store the temp files in something like ./__temp/

import math
import multiprocessing
import os
import re
import subprocess
import sys
DIR = os.path.dirname(os.path.realpath(__file__))


def main():
    assert len(sys.argv) >= 2
    size = int(sys.argv[1])
    frames = 32

    try: os.mkdir(f'{DIR}/__frames')
    except FileExistsError: pass

    # reads the .svg into 'data' var and
    # adds the start/end radian vals of the circle in the "Animate" layer
    # to the 'iterations' group, such as [(s1, e1), (s2, e2)]
    iterations = []
    data = ""
    with open(f'{DIR}/cursor_loading.svg', mode='r') as svg:
        data = svg.read()
        # two separate searches cause at one point I saw "end" before "start"
        start = float(re.search(r'inkscape:label="Animate".+?sodipodi:start="(.+?)"', data, re.DOTALL).group(1))
        end = float(re.search(r'inkscape:label="Animate".+?sodipodi:end="(.+?)"', data, re.DOTALL).group(1))
        arc = round(math.degrees(end - start))

        for x in range(frames):
            start = (360 / frames) * x
            end = start + arc
            if end > 360: end -= 360
            iterations += [(math.radians(start), math.radians(end))]

    # creates & starts inkscape processes
    # updates the data var read earlier and pipes it to inkscape's stdin
    processes = []
    for num, i in enumerate(iterations):
        # update start iter
        match = re.search(r'inkscape:label="Animate".+?sodipodi:start="(.+?)"', data, re.DOTALL)
        start, end = match.start(1), match.end(1)
        data = data[:start] + str(i[0]) + data[end:]

        # update end iter. re-serach in case length changed from updating start
        match = re.search(r'inkscape:label="Animate".+?sodipodi:end="(.+?)"', data, re.DOTALL)
        start, end = match.start(1), match.end(1)
        data = data[:start] + str(i[1]) + data[end:]

        # create process, start, and add to 'processes' list.
        p = multiprocessing.Process(
            target=subprocess.run,
            args=[['inkscape', '-w', f'{size}', '-h', f'{size}', '-o', f'{DIR}/__frames/{num:04d}.png', '-p']],
            kwargs={"input": bytes(data, encoding='UTF-8')}
        )
        p.start()
        processes.append(p)

    # basically `wait`
    for p in processes: p.join()


if __name__ == "__main__":
    main()
